<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[自学用Python 3开发网络爬虫(二)]]></title>
      <url>%2F2017%2F02%2F28%2F%E8%87%AA%E5%AD%A6%E7%94%A8Python%203%E5%BC%80%E5%8F%91%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB(%E4%BA%8C)%2F</url>
      <content type="text"><![CDATA[代码实现(一): 用Python抓取指定页面在Python中，我们使用urllib这个组件来抓取网页。urllib是Python的一个获取URLs(Uniform Resource Locators)的组件。它以urlopen函数的形式提供了一个非常简单的接口。最简单的urllib的应用代码只需要五行。我们新建一个文件urllib_test01.py来感受一下urllib的作用：12345import urllib.requesturl = &quot;http://www.baidu.com&quot;data = urllib.request.urlopen(url).read()data = data.decode(&apos;UTF-8&apos;)print(data) 按下Shift+F10可以看到运行的结果：urllib.request是一个库, 隶属urllib.点击https://docs.python.org/3/library/urllib.html 。首先点刚刚提到的这个链接进去的页面有urllib的几个子库, 我们暂时用到了request, 所以我们先看urllib.request部分. 首先看到的是一句话介绍这个库是干什么用的：1The urllib.request module defines functions and classes which help in opening URLs (mostly HTTP) in a complex world — basic and digest authentication, redirections, cookies and more. 然后把我们代码中用到的urlopen()函数部分阅读完.1urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False) 重点部分是返回值, 这个函数返回一个 http.client.HTTPResponse 对象, 这个对象又有各种方法, 比如我们用到的read()方法, 这些方法都可以根据官方文档的链接链过去。 代码实现(二): 用Python简单处理URL如果要抓取百度上面搜索关键词为Jecvay Notes的网页, 则代码如下：123456789101112import urllibimport urllib.requestdata = &#123;&#125;data[&apos;word&apos;] = &apos;Jecvay Notes&apos;url_values = urllib.parse.urlencode(data)url = &quot;http://www.baidu.com/s?&quot;full_url = url + url_valuesdata = urllib.request.urlopen(full_url).read()data = data.decode(&apos;UTF-8&apos;)print(data) data是一个字典, 然后通过urllib.parse.urlencode()来将data转换为 ‘word=Jecvay+Notes’的字符串, 最后和url合并为full_url, 其余和上面那个最简单的例子相同.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java程序员必须掌握的8大排序算法]]></title>
      <url>%2F2017%2F02%2F28%2FJava%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%848%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[8种排序之间的关系: 直接插入排序 基本思想：在要排序的一组数中，假设前面(n-1)[n&gt;=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。 实例 用java实现 12345678910111213141516public class insertSort &#123; public insertSort()&#123; inta[]=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;; int temp=0; for(int i=1;i&lt;a.length;i++)&#123; int j=i-1; temp=a[i]; for(;j&gt;=0&amp;&amp;temp&lt;a[j];j--)&#123; a[j+1]=a[j]; //将大于temp的值整体后移一个单位 &#125; a[j+1]=temp; &#125; for(int i=0;i&lt;a.length;i++) System.out.println(a[i]); &#125; &#125; 希尔排序（最小增量排序） 基本思想：算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。 实例： 用java实现 12345678910111213141516171819202122232425public class shellSort &#123; public shellSort()&#123; int a[]=&#123;1,54,6,3,78,34,12,45,56,100&#125;; double d1=a.length; int temp=0; while(true)&#123; d1= Math.ceil(d1/2); int d=(int) d1; for(int x=0;x&lt;d;x++)&#123; for(int i=x+d;i&lt;a.length;i+=d)&#123; int j=i-d; temp=a[i]; for(;j&gt;=0&amp;&amp;temp&lt;a[j];j-=d)&#123; a[j+d]=a[j]; &#125; a[j+d]=temp; &#125; &#125; if(d==1) break; &#125; for(int i=0;i&lt;a.length;i++) System.out.println(a[i]); &#125; &#125; 简单选择排序 基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。 实例： 用java实现12345678910111213141516171819202122public class selectSort &#123; public selectSort()&#123; int a[]=&#123;1,54,6,3,78,34,12,45&#125;; int position=0; for(int i=0;i&lt;a.length;i++)&#123; int j=i+1; position=i; int temp=a[i]; for(;j&lt;a.length;j++)&#123; if(a[j]&lt;temp)&#123; temp=a[j]; position=j; &#125; &#125; a[position]=a[i]; a[i]=temp; &#125; for(int i=0;i&lt;a.length;i++) System.out.println(a[i]); &#125; &#125; 堆排序 基本思想：堆排序是一种树形选择排序，是对直接选择排序的有效改进。堆的定义如下：具有n个元素的序列（h1,h2,…,hn),当且仅当满足（hi&gt;=h2i,hi&gt;=2i+1）或（hi&lt;=h2i,hi&lt;=2i+1） (i=1,2,…,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。 实例： 初始序列：46,79,56,38,40,84 建堆： 交换，从堆中踢出最大数 剩余节点在建堆，再交换踢出最大数依次类推：最后堆中剩余的最后两个结点交换，踢出一个，排序完成。 用java实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Arrays; public class HeapSort &#123; int a[]=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;; public HeapSort()&#123; heapSort(a); &#125; public void heapSort(int[] a)&#123; System.out.println(&quot;开始排序&quot;); int arrayLength=a.length; //循环建堆 for(int i=0;i&lt;arrayLength-1;i++)&#123; //建堆 buildMaxHeap(a,arrayLength-1-i); //交换堆顶和最后一个元素 swap(a,0,arrayLength-1-i); System.out.println(Arrays.toString(a)); &#125; &#125; private void swap(int[] data, int i, int j) &#123; // TODO Auto-generated method stub int tmp=data[i]; data[i]=data[j]; data[j]=tmp; &#125; //对data数组从0到lastIndex建大顶堆 private void buildMaxHeap(int[] data, int lastIndex) &#123; // TODO Auto-generated method stub //从lastIndex处节点（最后一个节点）的父节点开始 for(int i=(lastIndex-1)/2;i&gt;=0;i--)&#123; //k保存正在判断的节点 int k=i; //如果当前k节点的子节点存在 while(k*2+1&lt;=lastIndex)&#123; //k节点的左子节点的索引 int biggerIndex=2*k+1; //如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在 if(biggerIndex&lt;lastIndex)&#123; //若果右子节点的值较大 if(data[biggerIndex]&lt;data[biggerIndex+1])&#123; //biggerIndex总是记录较大子节点的索引 biggerIndex++; &#125; &#125; //如果k节点的值小于其较大的子节点的值 if(data[k]&lt;data[biggerIndex])&#123; //交换他们 swap(data,k,biggerIndex); //将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值 k=biggerIndex; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125; 冒泡排序 基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。 实例： 用java实现1234567891011121314151617public class bubbleSort &#123; public bubbleSort()&#123; int a[]=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;; int temp=0; for(int i=0;i&lt;a.length-1;i++)&#123; for(int j=0;j&lt;a.length-1-i;j++)&#123; if(a[j]&gt;a[j+1])&#123; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125; &#125; for(int i=0;i&lt;a.length;i++) System.out.println(a[i]); &#125; &#125; 快速排序 基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。 实例： 用java实现123456789101112131415161718192021222324252627282930313233343536public class quickSort &#123; int a[]=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;; public quickSort()&#123; quick(a); for(int i=0;i&lt;a.length;i++) System.out.println(a[i]); &#125; public int getMiddle(int[] list, int low, int high) &#123; int tmp = list[low]; //数组的第一个作为中轴 while (low &lt; high) &#123; while (low &lt; high &amp;&amp; list[high] &gt;= tmp) &#123; high--; &#125; list[low] = list[high]; //比中轴小的记录移到低端 while (low &lt; high &amp;&amp; list[low] &lt;= tmp) &#123; low++; &#125; list[high] = list[low]; //比中轴大的记录移到高端 &#125; list[low] = tmp; //中轴记录到尾 return low; //返回中轴的位置 &#125; public void _quickSort(int[] list, int low, int high) &#123; if (low &lt; high) &#123; int middle = getMiddle(list, low, high); //将list数组进行一分为二 _quickSort(list, low, middle - 1); //对低字表进行递归排序 _quickSort(list, middle + 1, high); //对高字表进行递归排序 &#125; &#125; public void quick(int[] a2) &#123; if (a2.length &gt; 0) &#123; //查看数组是否为空 _quickSort(a2, 0, a2.length - 1); &#125; &#125; &#125; 归并排序 基本排序：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。 实例： 用java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.Arrays; public class mergingSort &#123; int a[]=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;; public mergingSort()&#123; sort(a,0,a.length-1); for(int i=0;i&lt;a.length;i++) System.out.println(a[i]); &#125; public void sort(int[] data, int left, int right) &#123; // TODO Auto-generated method stub if(left&lt;right)&#123; //找出中间索引 int center=(left+right)/2; //对左边数组进行递归 sort(data,left,center); //对右边数组进行递归 sort(data,center+1,right); //合并 merge(data,left,center,right); &#125; &#125; public void merge(int[] data, int left, int center, int right) &#123; // TODO Auto-generated method stub int [] tmpArr=new int[data.length]; int mid=center+1; //third记录中间数组的索引 int third=left; int tmp=left; while(left&lt;=center&amp;&amp;mid&lt;=right)&#123; //从两个数组中取出最小的放入中间数组 if(data[left]&lt;=data[mid])&#123; tmpArr[third++]=data[left++]; &#125;else&#123; tmpArr[third++]=data[mid++]; &#125; &#125; //剩余部分依次放入中间数组 while(mid&lt;=right)&#123; tmpArr[third++]=data[mid++]; &#125; while(left&lt;=center)&#123; tmpArr[third++]=data[left++]; &#125; //将中间数组中的内容复制回原数组 while(tmp&lt;=right)&#123; data[tmp]=tmpArr[tmp++]; &#125; System.out.println(Arrays.toString(data)); &#125; &#125; 基数排序 基本思想：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。 实例： 用java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.ArrayList; import java.util.List; public class radixSort &#123; int a[]=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,101,56,17,18,23,34,15,35,25,53,51&#125;; public radixSort()&#123; sort(a); for(int i=0;i&lt;a.length;i++) System.out.println(a[i]); &#125; public void sort(int[] array)&#123; //首先确定排序的趟数; int max=array[0]; for(int i=1;i&lt;array.length;i++)&#123; if(array[i]&gt;max)&#123; max=array[i]; &#125; &#125; int time=0; //判断位数; while(max&gt;0)&#123; max/=10; time++; &#125; //建立10个队列; List&lt;ArrayList&gt; queue=new ArrayList&lt;ArrayList&gt;(); for(int i=0;i&lt;10;i++)&#123; ArrayList&lt;Integer&gt; queue1=new ArrayList&lt;Integer&gt;(); queue.add(queue1); &#125; //进行time次分配和收集; for(int i=0;i&lt;time;i++)&#123; //分配数组元素; for(int j=0;j&lt;array.length;j++)&#123; //得到数字的第time+1位数; int x=array[j]%(int)Math.pow(10, i+1)/(int)Math.pow(10, i); ArrayList&lt;Integer&gt; queue2=queue.get(x); queue2.add(array[j]); queue.set(x, queue2); &#125; int count=0;//元素计数器; //收集队列元素; for(int k=0;k&lt;10;k++)&#123; while(queue.get(k).size()&gt;0)&#123; ArrayList&lt;Integer&gt; queue3=queue.get(k); array[count]=queue3.get(0); queue3.remove(0); count++; &#125; &#125; &#125; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自学用Python 3开发网络爬虫(一)]]></title>
      <url>%2F2017%2F02%2F18%2F%E8%87%AA%E5%AD%A6%E7%94%A8Python%203%E5%BC%80%E5%8F%91%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB(%E4%B8%80)%2F</url>
      <content type="text"><![CDATA[网络爬虫的定义网络爬虫，即Web Spider，是一个很形象的名字。把互联网比喻成一个蜘蛛网，那么Spider就是在网上爬来爬去的蜘蛛。网络蜘蛛是通过网页的链接地址来寻找网页的。从网站某一个页面（通常是首页）开始，读取网页的内容，找到在网页中的其它链接地址，然后通过这些链接地址寻找下一个网页，这样一直循环下去，直到把这个网站所有的网页都抓取完为止。如果把整个互联网当成一个网站，那么网络蜘蛛就可以用这个原理把互联网上所有的网页都抓取下来。这样看来，网络爬虫就是一个爬行程序，一个抓取网页的程序。网络爬虫的基本操作是抓取网页。那么如何才能随心所欲地获得自己想要的页面？我们先从URL开始。 浏览网页的过程抓取网页的过程其实和读者平时使用IE浏览器浏览网页的道理是一样的。比如说你在浏览器的地址栏中输入 www.baidu.com 这个地址。打开网页的过程其实就是浏览器作为一个浏览的“客户端”，向服务器端发送了 一次请求，把服务器端的文件“抓”到本地，再进行解释、展现。HTML是一种标记语言，用标签标记内容并加以解析和区分。浏览器的功能是将获取到的HTML代码进行解析，然后将原始的代码转变成我们直接看到的网站页面。 URI和URL的概念和举例简单的来讲，URL就是在浏览器端输入的http://www.baidu.com这个字符串。在理解URL之前，首先要理解URI的概念。什么是URI？Web上每种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个通用资源标志符(Universal Resource Identifier， URI)进行定位。URI通常由三部分组成： 访问资源的命名机制； 存放资源的主机名； 资源自身 的名称，由路径表示。 如下面的URI：http://www.why.com.cn/myhtml/html1223/我们可以这样解释它： 这是一个可以通过HTTP协议访问的资源， 位于主机 www.webmonkey.com.cn上， 通过路径“/html/html40”访问。 URL的理解和举例URL是URI的一个子集。它是Uniform Resource Locator的缩写，译为“统一资源定位 符”。通俗地说，URL是Internet上描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL的一般格式为(带方括号[]的为可选项)：protocol :// hostname[:port] / path / [;parameters][?query]#fragment URL的格式由三部分组成： 第一部分是协议(或称为服务方式)。 第二部分是存有该资源的主机IP地址(有时也包括端口号)。 第三部分是主机资源的具体地址，如目录和文件名等。 第一部分和第二部分用“://”符号隔开；第二部分和第三部分用“/”符号隔开；第一部分和第二部分是不可缺少的，第三部分有时可以省略。 URL和URI简单比较URI属于URL更低层次的抽象，一种字符串文本标准。换句话说，URI属于父类，而URL属于URI的子类。URL是URI的一个子集。URI的定义是：统一资源标识符；URL的定义是：统一资源定位符。二者的区别在于，URI表示请求服务器的路径，定义这么一个资源。而URL同时说明要如何访问这个资源（http://）。下面来看看两个URL的小例子。 HTTP协议的URL示例：使用超级文本传输协议HTTP，提供超级文本信息服务的资源。例：http://www.peopledaily.com.cn/channel/welcome.htm其计算机域名为www.peopledaily.com.cn。超级文本文件(文件类型为.html)是在目录 /channel下的welcome.htm。这是中国人民日报的一台计算机。例：http://www.rol.cn.NET/talk/talk1.htm其计算机域名为www.rol.cn.Net。超级文本文件(文件类型为.html)是在目录/talk下的talk1.htm。这是瑞得聊天室的地址，可由此进入瑞得聊天室的第1室。 文件的URL用URL表示文件时，服务器方式用file表示，后面要有主机IP地址、文件的存取路 径(即目录)和文件名等信息。有时可以省略目录和文件名，但“/”符号不能省略。例：file://ftp.yoyodyne.com/pub/files/foobar.txt上面这个URL代表存放在主机ftp.yoyodyne.com上的pub/files/目录下的一个文件，文件名是foobar.txt。例：file://ftp.yoyodyne.com/pub代表主机ftp.yoyodyne.com上的目录/pub。例：file://ftp.yoyodyne.com/代表主机ftp.yoyodyne.com的根目录。 爬虫最主要的处理对象就是URL，它根据URL地址取得所需要的文件内容，然后对它 进行进一步的处理。因此，准确地理解URL对理解网络爬虫至关重要。 选择一门语言爬虫可以用各种语言写, C++, Java都可以, 为什么要Python? 首先用C++搞网络开发的例子不多(可能是我见得太少), 然后由于Oracle收购了Sun, Java目前虽然在Android开发上很重要, 但是如果Google官司进展不顺利, 那么很有可能用Go语言替代掉Java来做Android开发. 在这计算机速度高速增长的年代里, 选语言都要看他爹的业绩, 真是稍不注意就落后于时代. 随着计算机速度的高速发展, 某种语言开发的软件运行的时间复杂度的常数系数已经不像以前那么重要, 我们可以越来越偏爱为程序员打造的而不是为计算机打造的语言. 比如Ruby这种传说中的纯种而又飘逸的的OOP语言, 或者Python这种稍严谨而流行库又非常多的语言, 都大大弱化了针对计算机运行速度而打造的特性, 强化了为程序员容易思考而打造的特性. 所以我选择Python。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【搭建Hexo博客】简明教程（二）]]></title>
      <url>%2F2017%2F02%2F18%2F%E3%80%90%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E3%80%91%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[让你的page页面也支持 多说 / DISQUS 评论系统Next主题默认page模板是没有评论的，如生成的标签云页面，分类页面，about页面等，都是不支持评论的。如果想默认page模板也支持评论，需要更改NexT主题page.swig文件。page.swig的路径： blog/themes/next/layout/page.swig把下面的代码12345678910111213&#123;% if page.comments %&#125;&lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt;&#123;% if (config.duoshuo and config.duoshuo.shortname) or config.duoshuo_shortname %&#125; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&#123;&#123; page.path &#125;&#125;&quot; data-title=&quot;&#123;&#123; page.title &#125;&#125;&quot; data-url=&quot;&#123;&#123; page.permalink &#125;&#125;&quot;&gt; &lt;/div&gt;&#123;% elseif config.disqus_shortname %&#125; &lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt;&#123;% endif %&#125;&lt;/div&gt;&#123;% endif %&#125; 复制到1234 &#123;&#123; page.content &#125;&#125; &#123;% endif %&#125; //上面的代码复制到这里&lt;/div&gt; 接着将下面的代码1234&#123;% block comment_system %&#125; &#123;% include &apos;_scripts/comments/duoshuo.swig&apos; %&#125; &#123;% include &apos;_scripts/comments/disqus.swig&apos; %&#125;&#123;% endblock %&#125; 复制到下面代码的底部1234&#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125;&#123;% endblock %&#125;//代码插在这里 保存。这时候，你新建的page页面除了标签云页面、分类页面均支持评论了，如about页面,效果如下： NexT主题添加腾讯空间404公益页面原来主题也有介绍了如何在增加腾讯公益404页面，但是整个页面跳了出去，我个人比较喜欢下面404页面嵌在内页这种风格使用方法一样，新建404.html页面，将下面代码拷进去保存，放到主题的source目录下即可：1234567891011121314&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;404 - Scorpio Deng&apos;blog&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;404错误，页面不存在！&quot;&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://qzonestyle.gtimg.cn/qzone_v6/lostchild/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; hexo NexT主题首页title的优化更改index.swig文件，文件路径是blog\themes\next\layout，将下面代码1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改成1&#123;% block title %&#125; &#123;&#123; config.title&#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 这时候你的首页标题会更符合网站名称 - 网站描述这习惯。seo优化，把关键词也显示在Title标题里，也可改成1&#123;% block title %&#125; &#123;&#123; theme.keywords &#125;&#125; - &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 注意：关键字出现在title标题里是有利于seo优化的，前提是你的目标关键词已经确定好。如果确定好的话，尽可能让它们在title标题尽量靠前，同时标题总字数注意控制在80个字符以内，切勿堆砌关键字。title的标点符号：关键词分割符号英文半角逗号，_ | ;品牌与关键词分割符号 -。 修改hexo最近访客样式通过多说后台管理&gt;设置&gt;基本设置&gt;自定义CSS修改最近访客css样式1234567891011121314151617181920212223242526272829303132333435363738#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123;width: 54px;height: 54px; /*设置图像的长和宽，这里要根据自己的评论框情况更改*/border-radius: 27px; /*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/-webkit-border-radius: 27px; /*圆角效果：兼容webkit浏览器*/-moz-border-radius: 27px;box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/-webkit-box-shadow: inset 0 -1px 0 #3333sf;-webkit-transition: 0.4s;-webkit-transition: -webkit-transform 0.4s ease-out;transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/-moz-transition: -moz-transform 0.4s ease-out;&#125;#ds-reset .ds-avatar img:hover,#ds-recent-visitors .ds-avatar img:hover &#123;/*设置鼠标悬浮在头像时的CSS样式*/ box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);-webkit-box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);transform: rotateZ(360deg); /*图像旋转360度*/-webkit-transform: rotateZ(360deg);-moz-transform: rotateZ(360deg);&#125;#ds-thread #ds-reset .ds-textarea-wrapper textarea &#123;background: url(http://ww4.sinaimg.cn/small/649a4735gw1et7gnhy5fej20zk0m8q3q.jpg) right no-repeat;&#125;#ds-recent-visitors .ds-avatar &#123;float: left&#125;/*隐藏多说底部版权*/#ds-thread #ds-reset .ds-powered-by &#123;display: none;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【搭建Hexo博客】简明教程（一）]]></title>
      <url>%2F2017%2F02%2F16%2F%E3%80%90%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E3%80%91%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B(%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[为了将自己的博客搭建到GitHub，特地学习了一下hexo。hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页，相比jekyll生成静态网页的速度更快。 亮点Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架。通过Hexo我们可以快速创建自己的博客，仅需要几条命令就可以完成。 发布时，Hexo可以部署在自己的Node服务器上面，也可以部署github上面。对于个人用户来说，部署在github上好处颇多，不仅可以省去服务器的成本，还可以减少各种系统运维的麻烦事(系统管理、备份、网络)。所以，基于github的个人站点，正在开始流行起来… Hexo的官方网站：http://hexo.io/ ，也是基于Github构建的网站。 废话不多说，直接上干货！ Hexo安装系统环境： win7 64bit node v0.10.5 npm 1.2.19Hexo安装，要用全局安装，加-g参数。1$ npm install -g hexo-cli 查看hexo的版本12345678910111213$ hexo vhexo: 3.2.2hexo-cli: 1.0.2os: Windows_NT 6.1.7601 win32 x64http_parser: 2.7.0node: 6.9.5v8: 5.1.281.89uv: 1.9.1zlib: 1.2.8ares: 1.10.1-DEVicu: 57.1modules: 48openssl: 1.0.2k 本地部署Hexo新建一个存放博客目录的文件夹，例如：blog进入到blog文件夹 hexo init blog 然后 npm install,博客安装完毕hexo s 启动博客打开浏览器 http://127.0.0.1:4000/ 即可访问出现了默认的网页界面，是不是很容易呢！ 主题个人觉得 Next主题NexT 是目前最清爽，集成度最好的一个，NexT主题是我接触Hexo的第一款主题，一见钟情的一款Hexo主题。虽然NexT主题简约却并不简单，功能特性多样；响应式设计，电脑手机访问体验好，超级nice！如果结合你自己网站的实际增删改其中一些细节，那更加prefect了。NexT相关教程：http://http://theme-next.iissnan.com/getting-started.html Hexo的使用创建新文章我们开始新博客了，创建第一博客文章。Hexo建议通过命令行操作，当然你也可以直接在_posts目录下创建文件。 通过命令创建新文章12$ hexo new 【搭建Hexo博客】简明教程INFO Created: D:\blog\source\_posts\【搭建Hexo博客】简明教程.md 在_posts目录下，就会生成文件：关于markdown语法写文章可以自行到网上搜索，这里就不想详细介绍了。 发布项目到github静态化处理写完了文章，我们就可以发布了。要说明的一点是hexo的静态博客框架，那什么是静态博客呢？静态博客，是只包含html, javascript, css文件的网站，没有动态的脚本。虽然我们是用Node进行的开发，但博客的发布后就与Node无关了。在发布之前，我们要通过一条命令，把所有的文章都做静态化处理，就是生成对应的html, javascript, css，使得所有的文章都是由静态文件组成的。静态化命令1234567891011121314$ hexo gINFO Start processingINFO Files loaded in 1.88 sINFO Generated: atom.xmlINFO Generated: sitemap.xmlINFO Generated: index.htmlINFO Generated: 404.html.bakINFO Generated: archives/index.htmlINFO Generated: categories/index.htmlINFO Generated: about/index.htmlINFO Generated: tags/index.htmlINFO Generated: CNAMEINFO Generated: images/algolia_logo.svgINFO Generated: archives/2017/02/index.html 在本地目录下，会生成一个public的目录，里面包括了所有静态化的文件。 发布到github接下来，我们把这个博客发布到github。 在github中创建一个项目nodejs-hexo，项目地址：https://github.com/scorpiodeng/nodejs-hexo.git 如何将你的github仓库部署到github pageshttp://http://blog.csdn.net/CherishLyf/article/details/48681545 设置域名接下来，我们配置好域名，这个路径就会正确的。比如，我有一个域名是 scorpiodeng.me，为了中国DNS解析，我先把域名绑定在Dnspod管理，再做跳转。域名有两种配置方式： 主域名绑定：直接绑定主域名XXX.me 子域名绑定：绑定子域名blog.XXX.me 主域名绑定在dnspod控制台，设置主机记录@，类型A，到IP 192.30.252.153。在github项目中，新建一个文件CNAME，文件中写出你要绑定的域名，通过浏览器，访问 http://XXX.me ， 就打开了我们建好的博客站点。 子域名绑定有时候，我们的主域名正在使用着，需要先新建一个博客绑定到子域名。在dnspod控制台，我们要做3步设置。 设置主机记录github，类型A，到IP 199.27.76.133 设置主机记录XXX.github.io，类型CNAME，到github.XXX.me. 设置主机记录blog，类型CNAME，到 XXX.github.io由于每次执行发布的时候，gh-pages分支所有的文件都会被覆盖，所以我们最好在source目录下创建这个CNAME文件，这样每次部署就不用动手创建了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cookie与Session的区别]]></title>
      <url>%2F2017%2F02%2F16%2FCookie%E4%B8%8ESession%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[针对会话机制，本文分别对Cookie与Session做一个介绍和总结，并分别对两个知识点进行对比分析。 Cookie机制Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。IETF RFC 2965 HTTP State Management Mechanism 是通用cookie规范。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。 正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。 而session机制采用的是一种在服务器端保持状态的解决方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的。而session提供了方便管理全局变量的方式 。 session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器。 就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的session机制更安全些，因为它不会任意读取客户存储的信息。 Session机制session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。 经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。 Cookie与Session都能够进行会话跟踪，但是完成的原理不太一样。普通状况下二者均能够满足需求，但有时分不能够运用Cookie，有时分不能够运用Session。下面经过比拟，阐明二者的特性以及适用的场所: 存取方式 Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比拟艰难的。 而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。 隐私策略 Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。 假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。 有效期 使用过Google的人都晓得，假如登录过Google，则Google的登录信息长期有效。用户不用每次访问都重新登录，Google会持久地记载该用户的登录信息。要到达这种效果，运用Cookie会是比较好的选择。只需要设置Cookie的过期时间属性为一个很大很大的数字。 由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。 跨域支持 Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。 仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。 浏览器支持 Cookie是需要客户端浏览器支持的。假如客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。关于WAP上的应用，常规的Cookie就派不上用场了。 假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。需要注意的是一切的用到Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。关于WAP应用来说，Session+URL地址重写或许是它唯一的选择。 假如客户端支持Cookie，则Cookie既能够设为本浏览器窗口以及子窗口内有效（把过期时间设为–1），也能够设为一切阅读器窗口内有效（把过期时间设为某个大于0的整数）。但Session只能在本阅读器窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session。 服务器压力 Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。 而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[有关Java方法参数是引用调用还是值调用的问题]]></title>
      <url>%2F2017%2F02%2F15%2F%E6%9C%89%E5%85%B3Java%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E6%98%AF%E5%BC%95%E7%94%A8%E8%B0%83%E7%94%A8%E8%BF%98%E6%98%AF%E5%80%BC%E8%B0%83%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[方法调用(call by)是一个标准的计算机科学术语。方法调用根据参数传递的情况又分为值调用(call by reference)和引用调用(call by value)。江湖上有很多关于这两种调用的定义 ，最通常的说法是传递值的是值调用，传递地址的是引用调用。这其实很不恰当，这种这些说法很容易让我们联想到Java的对象参数传递是引用调用，实际上，Java的对象参数传递仍然是值调用。我们首先用一段代码来证实一下为什么Java的对象参数传递是值调用。上面的结果让人很失望，虽然形参对象e1,e2的内容交换了，但实参对象worker,manager并没有互换内容。这里面最重要的原因就在于形参e1,e2是实参worker,manager的地址拷贝。 大家都知道，在Java中对象变量名实际上代表的是对象在堆中的地址(专业术语叫做对象引用)。在Java方法调用的时候，参数传递的是对象的引用。重要的是，形参和实参所占的内存地址并不一样，形参中的内容只是实参中存储的对象引用的一份拷贝。 如果大家对JVM内存管理中Java栈的局部变量区有所了解的话，就很好理解上面这句话。在JVM运行上面的程序时，运行main方法和swap方法，会在Java栈中先后push两个叫做栈帧的内存空间。main栈帧中有一块叫局部变量区的内存用来存储实参对象worker和manager的引用。而swap栈帧中的局部变量区则存储了形参对象e1和e2的引用。虽然e1和e2的引用值分别与worker和manager相同，但是它们占用了不同的内存空间。当e1和e2的引用发生交换时，下面的图很清晰的看出完全不会影响worker和manager的引用值。Java对象参数传递虽然传递的是地址(引用)，但仍然是值调用。 值调用(call by value)：在参数传递过程中，形参和实参占用了两个完全不同的内存空间。形参所存储的内容是实参存储内容的一份拷贝。实际上，Java对象的传递就符合这个定义，只不过形参和实参所储存的内容并不是常规意义上的变量值，而是变量的地址。 引用调用(call by reference)：在参数传递的过程中，形参和实参完全是同一块内存空间，两者不分彼此。实际上，形参名和实参名只是编程中的不同符号，在程序运行过程中，内存中存储的空间才是最重要的。不同的变量名并不能说明占用的内存存储空间不同。 大体上说，两种调用的根本并不在于传递的是值还是地址(毕竟地址也是一个值)，而是在于形参和实参是否占用同一块内存空间。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[有关Java中的静态与动态绑定机制]]></title>
      <url>%2F2017%2F02%2F15%2F%E6%9C%89%E5%85%B3Java%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[这篇文章主要分析的是JVM方法调用的静态(static binding)和动态绑定机制(auto binding)。 静态绑定机制上面的源代码中执行方法调用的语句(Father.f1())被编译器编译成了一条指令：invokestatic #13。我们看看JVM是如何处理这条指令的： 指令中的#13指的是StaticCall类的常量池中第13个常量表的索引项。这个常量表(CONSTATN_Methodref_info)记录的是方法f1信息的符号引用(包括f1所在的类名，方法名和返回类型)。JVM会首先根据这个符号引用找到方法f1所在的类的全限定名: hr.test.Father。 紧接着JVM会加载、链接和初始化Father类。 然后在Father类所在的方法区中找到f1()方法的直接地址，并将这个直接地址记录到StaticCall类的常量池索引为13的常量表中。这个过程叫常量池解析，以后再次调用Father.f1()时，将直接找到f1方法的字节码。 完成了StaticCall类常量池索引项13的常量表的解析之后，JVM就可以调用f1()方法，并开始解释执行f1()方法中的指令了。 通过上面的过程，我们发现经过常量池解析之后，JVM就能够确定要调用的f1()方法具体在内存的什么位置上了。实际上，这个信息在编译阶段就已经在StaticCall类的常量池中记录了下来。这种在编译阶段就能够确定调用哪个方法的方式，我们叫做静态绑定机制。 除了被static修饰的静态方法，所有被private修饰的私有方法、被final修饰的禁止子类覆盖的方法都会被编译成invokestatic指令。另外所有类的初始化方法和会被编译成invokespecial指令。JVM会采用静态绑定机制来顺利的调用这些方法。 动态绑定机制上面的源代码中有三个重要的概念：多态(polymorphism)、方法覆盖、方法重载。打印的结果大家也都比较清楚，但是JVM是如何知道f.f1()调用的是子类Sun中方法而不是Father中的方法呢？在解释这个问题之前，我们首先简单的讲下JVM管理的一个非常重要的数据结构——方法表。 在JVM加载类的同时，会在方法区中为这个类存放很多信息。其中就有一个数据结构叫方法表。它以数组的形式记录了当前类及其所有超类的可见方法字节码在内存中的直接地址。下图是上面源代码中Father和Sun类在方法区中的方法表：上图中的方法表有两个特点：(1) 子类方法表中继承了父类的方法，比如Father extends Object。 (2) 相同的方法(相同的方法签名：方法名和参数列表)在所有类的方法表中的索引相同。比如Father方法表中的f1()和Son方法表中的f1()都位于各自方法表的第11项中。 对于上面的源代码，编译器首先会把main方法编译成下面的字节码指令：其中invokevirtual指令的详细调用过程是这样的： invokevirtual指令中的#15指的是AutoCall类的常量池中第15个常量表的索引项。这个常量表(CONSTATN_Methodref_info)记录的是方法f1信息的符号引用(包括f1所在的类名，方法名和返回类型)。JVM会首先根据这个符号引用找到调用方法f1的类的全限定名: hr.test.Father。这是因为调用方法f1的类的对象father声明为Father类型。 在Father类型的方法表中查找方法f1，如果找到，则将方法f1在方法表中的索引项11(如上图)记录到AutoCall类的常量池中第15个常量表中(常量池解析)。这里有一点要注意：如果Father类型方法表中没有方法f1，那么即使Son类型中方法表有，编译的时候也通过不了。因为调用方法f1的类的对象father的声明为Father类型。 在调用invokevirtual指令前有一个aload_1指令，它会将开始创建在堆中的Son对象的引用压入操作数栈。然后invokevirtual指令会根据这个Son对象的引用首先找到堆中的Son对象，然后进一步找到Son对象所属类型的方法表。过程如下图所示： 这是通过第2步中解析完成的#15常量表中的方法表的索引项11，可以定位到Son类型方法表中的方法f1()，然后通过直接地址找到该方法字节码所在的内存空间。 很明显，根据对象(father)的声明类型(Father)还不能够确定调用方法f1的位置，必须根据father在堆中实际创建的对象类型Son来确定f1方法所在的位置。这种在程序运行过程中，通过动态创建的对象的方法表来定位方法的方式，我们叫做动态绑定机制。 上面的过程很清楚的反映出在方法覆盖的多态调用的情况下，JVM是如何定位到准确的方法的。但是下面的调用方法JVM是如何定位的呢？(仍然使用上面代码中的Father和Son类型) 问题是Fahter类型中并没有方法签名为f1(char)的方法呀。但打印结果显示JVM调用了Father类型中的f1(int)方法，并没有调用到Son类型中的f1(char)方法。 根据上面详细阐述的调用过程，首先可以明确的是：JVM首先是根据对象father声明的类型Father来解析常量池的(也就是用Father方法表中的索引项来代替常量池中的符号引用)。如果Father中没有匹配到”合适”的方法，就无法进行常量池解析，这在编译阶段就通过不了。 那么什么叫”合适”的方法呢？当然，方法签名完全一样的方法自然是合适的。但是如果方法中的参数类型在声明的类型中并不能找到呢？比如上面的代码中调用father.f1(char)，Father类型并没有f1(char)的方法签名。实际上，JVM会找到一种“凑合”的办法，就是通过参数的自动转型来找到“合适”的 方法。比如char可以通过自动转型成int，那么Father类中就可以匹配到这个方法了。 总结 所有私有方法、静态方法、构造器及初始化方法都是采用静态绑定机制。在编译器阶段就已经指明了调用方法在常量池中的符号引用，JVM运行的时候只需要进行一次常量池解析即可。 类对象方法的调用必须在运行过程中采用动态绑定机制。]]></content>
    </entry>

    
  
  
</search>
