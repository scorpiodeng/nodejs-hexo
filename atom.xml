<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scorpiodeng&#39;s Blog</title>
  <subtitle>Nothing great was ever achieved without enthusiasm.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.scorpiodeng.me/"/>
  <updated>2016-12-03T16:31:53.370Z</updated>
  <id>http://blog.scorpiodeng.me/</id>
  
  <author>
    <name>Scorpio Deng</name>
    <email>scorpio_dxledu@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面向对象的总结(一)</title>
    <link href="http://blog.scorpiodeng.me/2016/12/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <id>http://blog.scorpiodeng.me/2016/12/03/面向对象的总结(二)/</id>
    <published>2016-12-03T15:27:23.000Z</published>
    <updated>2016-12-03T16:31:53.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-对多态的理解"><a href="#1-对多态的理解" class="headerlink" title="1.对多态的理解"></a>1.对多态的理解</h2><pre><code>(1)多态就是事物存在的多种形态

(2)多态的前提

    a.要有继承关系。

    b.要有方法重写。

    c.要有父类引用指向子类对象。

(3)多态中的成员访问特点

    a.成员方法：编译时看父类(左边)，运行时看子类(右边)

    b.成员变量：编译时看父类(左边)，运行时看父类(右边)

    c.静态方法：编译看左边(父类)，运行看左边(父类)。

        (静态和类相关，算不上重写，所以，访问还是左边的)

        只有非静态的成员方法,编译看左边,运行看右边 

(4)多态的好处和弊端

    a.好处

        * 提高了代码的维护性(继承保证)

        * 提高了代码的扩展性(由多态保证)，可以当作形式参数,可以接收任意子类对象

    b.弊端

        * 不能使用子类的特有属性和行为
</code></pre><h2 id="2-对抽象类的理解"><a href="#2-对抽象类的理解" class="headerlink" title="2.对抽象类的理解"></a>2.对抽象类的理解</h2><pre><code>(1)抽象类的概述

    a.在某些情况下,父类只知道子类包含怎样的方法,无法准确知道这些子类如何实现该方法

    b.多个具有相同特征的类中抽取一个抽象类,以这个抽象类为子类的模板,从而避免子类设计的随意化

    c.限制子类必须有哪些方法,不关注实现细节.

(2)抽象类特点

    a.抽象类和抽象方法必须用abstract关键字修饰

        * abstract class 类名 {}

        * public abstract void 方法名();//当不知道该方法具体是怎么实现的                        

    b.抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口

    c.抽象类不能实例化那么，抽象类如何实例化呢?

        * 按照多态的方式，由具体的子类实例化。其实这也是多态的一种，抽象类多态。

    d.抽象类的子类

        * 要么是抽象类

        * 要么重写抽象类中的所有抽象方法

(3)抽象类的成员特点

    a.成员变量：既可以是变量，也可以是常量。abstract是否可以修饰成员变量?不能修饰成员变量

    b.构造方法：必须有。

        * 用于子类访问父类数据的初始化。

    c.成员方法：既可以是抽象的，也可以是非抽象的。

        * 抽象方法 强制要求子类做的事情。

        * 非抽象方法 子类继承的事情，提高代码复用性。
</code></pre><h2 id="3-abstract关键字不能与哪些关键字共同使用"><a href="#3-abstract关键字不能与哪些关键字共同使用" class="headerlink" title="3.abstract关键字不能与哪些关键字共同使用"></a>3.abstract关键字不能与哪些关键字共同使用</h2><pre><code>(1)abstract和static

    被abstract修饰的方法没有方法体

    被static修饰的可以用类名.调用,但是类名.调用抽象方法是没有意义的

(2)abstract和final

    被abstract修饰的方法强制子类重写

    被final修饰的不让子类重写,所以他俩是矛盾

(3)abstract和private

    被abstract修饰的是为了让子类看到并强制重写

    被private修饰不让子类访问,所以他俩是矛盾的
</code></pre><h2 id="4-对接口的理解"><a href="#4-对接口的理解" class="headerlink" title="4.对接口的理解"></a>4.对接口的理解</h2><pre><code>(1)接口概述

    a.从狭义的角度讲就是指java中的interface

    b.从广义的角度讲对外提供规则的都是接口 

(2)接口特点

    a.接口用关键字interface表示    

        * interface 接口名 {}

    b.类实现接口用implements表示

        * class 类名 implements 接口名 {}

    c.接口不能实例化

        * 那么，接口如何实例化呢?

        * 按照多态的方式来实例化。

    d.接口的子类

        * a:可以是抽象类。但是意义不大。

        * b:可以是具体类。要重写接口中的所有抽象方法。

(3)接口成员特点

    a.成员变量只能是常量，并且是静态的并公共的。

        * 默认修饰符：public static final

        * 建议：自己手动给出。

    b.构造方法：接口没有构造方法。

    c.成员方法：只能是抽象方法。

        * 默认修饰符：public abstract

        * 建议：自己手动给出。
</code></pre><h2 id="5-类与类-类与接口-接口与接口的关系"><a href="#5-类与类-类与接口-接口与接口的关系" class="headerlink" title="5.类与类,类与接口,接口与接口的关系"></a>5.类与类,类与接口,接口与接口的关系</h2><pre><code>(1)类与类：

    a.继承关系,只能单继承,可以多层继承。

(2)类与接口：

    a.实现关系,可以单实现,也可以多实现。

    b.并且还可以在继承一个类的同时实现多个接口。

(3)接口与接口：

    a.继承关系,可以单继承,也可以多继承。
</code></pre><h2 id="6-对抽象类和接口的理解"><a href="#6-对抽象类和接口的理解" class="headerlink" title="6.对抽象类和接口的理解"></a>6.对抽象类和接口的理解</h2><pre><code>(1)成员区别

    a.抽象类：

        * 成员变量：可以变量，也可以常量

        * 构造方法：有

        * 成员方法：可以抽象，也可以非抽象

    b.接口：

        * 成员变量：只可以常量

        * 成员方法：只可以抽象



(2)关系区别

    a.类与类

        * 继承，单继承

    b.类与接口

        * 实现，单实现，多实现

    c.接口与接口

        * 继承，单继承，多继承



(3)设计理念区别(面试时最好最初例子来)

    a.抽象类 被继承体现的是：”is a”的关系。抽象类中定义的是该继承体系的共性功能。

    b.接口 被实现体现的是：”like a”的关系。接口中定义的是该继承体系的扩展功能。 

        * 对事物本质的抽象用抽象类，对事物功能的扩展用接口
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-对多态的理解&quot;&gt;&lt;a href=&quot;#1-对多态的理解&quot; class=&quot;headerlink&quot; title=&quot;1.对多态的理解&quot;&gt;&lt;/a&gt;1.对多态的理解&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;(1)多态就是事物存在的多种形态

(2)多态的前提

    a.要有继承
    
    </summary>
    
      <category term="javaEE" scheme="http://blog.scorpiodeng.me/categories/javaEE/"/>
    
      <category term="面向对象" scheme="http://blog.scorpiodeng.me/categories/javaEE/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="开始" scheme="http://blog.scorpiodeng.me/tags/%E5%BC%80%E5%A7%8B/"/>
    
      <category term="笔记" scheme="http://blog.scorpiodeng.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的总结(一)</title>
    <link href="http://blog.scorpiodeng.me/2016/12/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%BB%E7%BB%93(%E4%B8%80)/"/>
    <id>http://blog.scorpiodeng.me/2016/12/03/面向对象的总结(一)/</id>
    <published>2016-12-03T03:46:52.000Z</published>
    <updated>2016-12-03T16:27:47.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-面向对象思想的特点"><a href="#1-面向对象思想的特点" class="headerlink" title="1.面向对象思想的特点"></a>1.面向对象思想的特点</h2><pre><code>(1)是一种更符合我们思想习惯的思想(懒人思想，我把事情自己不做，交给别人去做)

(2)可以将复杂的事情简单化（对使用者来说简单了，对象里面还是很复杂的）

(3)角色发生了转换，将我们从执行者变成了指挥者

(4)就是不断的创建对象，使用对象，指挥对象做事情。（如果有对象，直接用对象，对我们直接提供服务）
</code></pre> <a id="more"></a>
<h2 id="2-面向对象的特征"><a href="#2-面向对象的特征" class="headerlink" title="2.面向对象的特征"></a>2.面向对象的特征</h2><pre><code>(1)封装

(2)继承

(3)多态
</code></pre><h2 id="3-类与对象的关系"><a href="#3-类与对象的关系" class="headerlink" title="3.类与对象的关系"></a>3.类与对象的关系</h2><pre><code>(1)类是一组相关的属性和行为的集合（我们班所有的同学都具备相同的属性和行为，比如：姓名，年龄，学习，这样就把所有的学生成为学生类）

(2)对象是该类事物的具体体现（说某个同学时，他都具备自己特有的属性和行为）

(3)类是抽象(抽取出同类事物中相同的、相似的部分就叫抽象)的具体的或者是类是一般的，对象是特殊的

(4)类中可以包含成员变量、类变量、成员方法、类方法、构造函数、构造代码块、静态代码块等
</code></pre><h2 id="4-成员变量和局部变量的区别？"><a href="#4-成员变量和局部变量的区别？" class="headerlink" title="4.成员变量和局部变量的区别？"></a>4.成员变量和局部变量的区别？</h2><pre><code>(1)在类中的位置不同

    a.成员变量：在类中方法外

    b.局部变量：在方法定义中或者方法声明上

(2)在内存中的位置不同

    a.成员变量：在堆内存(成员变量属于对象,对象进堆内存)

    b.局部变量：在栈内存(局部变量属于方法,方法进栈内存)

(3)生命周期不同

    a.成员变量：随着对象的创建而存在，随着对象的消失而消失

    b.局部变量：随着方法的调用而存在，随着方法的调用完毕而消失

(4)初始化值不同

    a.成员变量：有默认初始化值

    b.局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。
</code></pre><h2 id="5-private关键字的特点"><a href="#5-private关键字的特点" class="headerlink" title="5.private关键字的特点"></a>5.private关键字的特点</h2><pre><code>(1)封装是指隐藏对象的属性和实现细节，仅对外提供公共访问方式，private是实现封装的一种形式

(2)private是一个权限修饰符，可以修饰成员变量和成员方法

(3)被private修饰的成员，只能在本类中访问

(4)当成员变量被private关键字修饰后，需要提供对应的get和set方法供外部访问
</code></pre><h2 id="6-谈谈你对this的理解？"><a href="#6-谈谈你对this的理解？" class="headerlink" title="6.谈谈你对this的理解？"></a>6.谈谈你对this的理解？</h2><pre><code>(1)this只能代表本类对象

(2)this代表所属函数(方法)的所属对象

(3)谁来调用我，我就代表谁

(4)this可用于区分成员变量和局部变量同名的情况
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-面向对象思想的特点&quot;&gt;&lt;a href=&quot;#1-面向对象思想的特点&quot; class=&quot;headerlink&quot; title=&quot;1.面向对象思想的特点&quot;&gt;&lt;/a&gt;1.面向对象思想的特点&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;(1)是一种更符合我们思想习惯的思想(懒人思想，我把事情自己不做，交给别人去做)

(2)可以将复杂的事情简单化（对使用者来说简单了，对象里面还是很复杂的）

(3)角色发生了转换，将我们从执行者变成了指挥者

(4)就是不断的创建对象，使用对象，指挥对象做事情。（如果有对象，直接用对象，对我们直接提供服务）
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="javaEE" scheme="http://blog.scorpiodeng.me/categories/javaEE/"/>
    
      <category term="面向对象" scheme="http://blog.scorpiodeng.me/categories/javaEE/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="开始" scheme="http://blog.scorpiodeng.me/tags/%E5%BC%80%E5%A7%8B/"/>
    
      <category term="笔记" scheme="http://blog.scorpiodeng.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
